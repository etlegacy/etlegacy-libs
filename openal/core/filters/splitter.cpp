
#include "config.h"

#include "splitter.h"

#include <algorithm>
#include <cmath>
#include <limits>
#include <numbers>

#include "gsl/gsl"


void BandSplitter::init(float f0norm)
{
    const auto w = f0norm * (std::numbers::pi_v<float>*2.0f);
    const auto cw = std::cos(w);
    if(cw > std::numeric_limits<float>::epsilon())
        mCoeff = (std::sin(w) - 1.0f) / cw;
    else
        mCoeff = cw * -0.5f;

    mLpZ1 = 0.0f;
    mLpZ2 = 0.0f;
    mApZ1 = 0.0f;
}

void BandSplitter::process(const std::span<const float> input, const std::span<float> hpout,
    const std::span<float> lpout)
{
    const auto ap_coeff = mCoeff;
    const auto lp_coeff = mCoeff*0.5f + 0.5f;
    auto lp_z1 = mLpZ1;
    auto lp_z2 = mLpZ2;
    auto ap_z1 = mApZ1;

    Expects(lpout.size() <= input.size());
    auto lpiter = lpout.begin();
    std::ranges::transform(input, hpout.begin(),
        [ap_coeff,lp_coeff,&lp_z1,&lp_z2,&ap_z1,&lpiter](const float in) noexcept -> float
    {
        /* Low-pass sample processing. */
        auto d = (in - lp_z1) * lp_coeff;
        auto lp_y = lp_z1 + d;
        lp_z1 = lp_y + d;

        d = (lp_y - lp_z2) * lp_coeff;
        lp_y = lp_z2 + d;
        lp_z2 = lp_y + d;

        *(lpiter++) = lp_y;

        /* All-pass sample processing. */
        const auto ap_y = in*ap_coeff + ap_z1;
        ap_z1 = in - ap_y*ap_coeff;

        /* High-pass generated from removing low-passed output. */
        return ap_y - lp_y;
    });
    mLpZ1 = lp_z1;
    mLpZ2 = lp_z2;
    mApZ1 = ap_z1;
}

void BandSplitter::processHfScale(const std::span<const float> input,
    const std::span<float> output, const float hfscale)
{
    const auto ap_coeff = mCoeff;
    const auto lp_coeff = mCoeff*0.5f + 0.5f;
    auto lp_z1 = mLpZ1;
    auto lp_z2 = mLpZ2;
    auto ap_z1 = mApZ1;
    std::ranges::transform(input, output.begin(),
        [hfscale,ap_coeff,lp_coeff,&lp_z1,&lp_z2,&ap_z1](const float in) noexcept -> float
    {
        /* Low-pass sample processing. */
        auto d = (in - lp_z1) * lp_coeff;
        auto lp_y = lp_z1 + d;
        lp_z1 = lp_y + d;

        d = (lp_y - lp_z2) * lp_coeff;
        lp_y = lp_z2 + d;
        lp_z2 = lp_y + d;

        /* All-pass sample processing. */
        const auto ap_y = in*ap_coeff + ap_z1;
        ap_z1 = in - ap_y*ap_coeff;

        /* High-pass generated by removing the low-passed signal, which is then
         * scaled and added back to the low-passed signal.
         */
        return (ap_y-lp_y)*hfscale + lp_y;
    });
    mLpZ1 = lp_z1;
    mLpZ2 = lp_z2;
    mApZ1 = ap_z1;
}

void BandSplitter::processHfScale(const std::span<float> samples, const float hfscale)
{
    const auto ap_coeff = mCoeff;
    const auto lp_coeff = mCoeff*0.5f + 0.5f;
    auto lp_z1 = mLpZ1;
    auto lp_z2 = mLpZ2;
    auto ap_z1 = mApZ1;
    std::ranges::transform(samples, samples.begin(),
        [hfscale,ap_coeff,lp_coeff,&lp_z1,&lp_z2,&ap_z1](const float in) noexcept -> float
    {
        /* Low-pass sample processing. */
        auto d = (in - lp_z1) * lp_coeff;
        auto lp_y = lp_z1 + d;
        lp_z1 = lp_y + d;

        d = (lp_y - lp_z2) * lp_coeff;
        lp_y = lp_z2 + d;
        lp_z2 = lp_y + d;

        /* All-pass sample processing. */
        const auto ap_y = in*ap_coeff + ap_z1;
        ap_z1 = in - ap_y*ap_coeff;

        /* High-pass generated by removing the low-passed signal, which is then
         * scaled and added back to the low-passed signal.
         */
        return (ap_y-lp_y)*hfscale + lp_y;
    });
    mLpZ1 = lp_z1;
    mLpZ2 = lp_z2;
    mApZ1 = ap_z1;
}

void BandSplitter::processScale(const std::span<float> samples, const float hfscale,
    const float lfscale)
{
    const auto ap_coeff = mCoeff;
    const auto lp_coeff = mCoeff*0.5f + 0.5f;
    auto lp_z1 = mLpZ1;
    auto lp_z2 = mLpZ2;
    auto ap_z1 = mApZ1;
    std::ranges::transform(samples, samples.begin(),
        [hfscale,lfscale,ap_coeff,lp_coeff,&lp_z1,&lp_z2,&ap_z1](const float in) noexcept -> float
    {
        auto d = (in - lp_z1) * lp_coeff;
        auto lp_y = lp_z1 + d;
        lp_z1 = lp_y + d;

        d = (lp_y - lp_z2) * lp_coeff;
        lp_y = lp_z2 + d;
        lp_z2 = lp_y + d;

        const auto ap_y = in*ap_coeff + ap_z1;
        ap_z1 = in - ap_y*ap_coeff;

        /* Apply separate factors to the high and low frequencies. */
        return (ap_y-lp_y)*hfscale + lp_y*lfscale;
    });
    mLpZ1 = lp_z1;
    mLpZ2 = lp_z2;
    mApZ1 = ap_z1;
}

void BandSplitter::processAllPass(const std::span<float> samples)
{
    const auto coeff = mCoeff;
    auto z1 = mApZ1;
    std::ranges::transform(samples, samples.begin(), [coeff,&z1](const float x) noexcept -> float
    {
        const auto y = x*coeff + z1;
        z1 = x - y*coeff;
        return y;
    });
    mApZ1 = z1;
}
